//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class NlpBaseClient {
    static URL_START = /^[^:]*:\/\/[^/]*\/?/.exec(location.href)![0];

  async transformOptions(options: RequestInit) {
        if (!options.credentials) options.credentials = 'same-origin';
        if (!options.headers) options.headers = {};
        if(Array.isArray(options.headers)) {
            if(!options.headers.some(r => r[0].localeCompare('Accept',void 0, {sensitivity: 'base'}) === 0))
                options.headers.push(['Accept','application/json']);
        }
        else if (typeof(options.headers.has) === 'function' && options.headers.has('Accept'))
            (<Headers>options.headers).set('Accept','application/json');
        else if (!(<Record<string, string>>options.headers).Accept)
            (<Record<string, string>>options.headers).Accept = 'application/json';
        return options;
  }

  async transformResult(url: string, response: Response, /** @type {(Response) => Promise} */processor: ((r: Response) => Promise<any>)) {
        if (response.status !== 401 || !response.url.startsWith(NlpBaseClient.URL_START) || response.headers.get('Content-Type') !== 'application/json')
            return await processor(response);

        location.href = (await response.json()).redirectTo;
        throw new Error('NLP server requested authentication.');
    }
}

export interface IAuthClient {

    whoAmI(includeClaims: boolean | undefined): Promise<WhoAmIResponse>;

    challenge(requestGoogleSelectAccount: boolean | undefined): Promise<WhoAmIResponse>;

    login(password: string | undefined): Promise<void>;

    logout(): Promise<void>;

    setNewPassword(request: SetNewPasswordRequest): Promise<string>;

    startFitbitFlow(): Promise<FileResponse | null>;

    processFitbitResponse(): Promise<FileResponse | null>;

    refreshFitBitToken(): Promise<FileResponse | null>;

    fitbitLoadDate(date: string): Promise<FileResponse | null>;
}

export class AuthClient extends NlpBaseClient implements IAuthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    whoAmI(includeClaims: boolean | undefined): Promise<WhoAmIResponse> {
        let url_ = this.baseUrl + "/api/Auth/whoami?";
        if (includeClaims === null)
            throw new Error("The parameter 'includeClaims' cannot be null.");
        else if (includeClaims !== undefined)
            url_ += "includeClaims=" + encodeURIComponent("" + includeClaims) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processWhoAmI(_response));
        });
    }

    protected processWhoAmI(response: Response): Promise<WhoAmIResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WhoAmIResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WhoAmIResponse>(null as any);
    }

    challenge(requestGoogleSelectAccount: boolean | undefined): Promise<WhoAmIResponse> {
        let url_ = this.baseUrl + "/api/Auth/authenticate?";
        if (requestGoogleSelectAccount === null)
            throw new Error("The parameter 'requestGoogleSelectAccount' cannot be null.");
        else if (requestGoogleSelectAccount !== undefined)
            url_ += "requestGoogleSelectAccount=" + encodeURIComponent("" + requestGoogleSelectAccount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processChallenge(_response));
        });
    }

    protected processChallenge(response: Response): Promise<WhoAmIResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WhoAmIResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WhoAmIResponse>(null as any);
    }

    login(password: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/login?";
        if (password === null)
            throw new Error("The parameter 'password' cannot be null.");
        else if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processLogin(_response));
        });
    }

    protected processLogin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    logout(): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processLogout(_response));
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    setNewPassword(request: SetNewPasswordRequest): Promise<string> {
        let url_ = this.baseUrl + "/api/Auth/set-new-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSetNewPassword(_response));
        });
    }

    protected processSetNewPassword(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    startFitbitFlow(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Auth/fitbit-start";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processStartFitbitFlow(_response));
        });
    }

    protected processStartFitbitFlow(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    processFitbitResponse(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Auth/fitbit";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processProcessFitbitResponse(_response));
        });
    }

    protected processProcessFitbitResponse(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    refreshFitBitToken(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Auth/fitbit-refresh";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRefreshFitBitToken(_response));
        });
    }

    protected processRefreshFitBitToken(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    fitbitLoadDate(date: string): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Auth/fitbit-load/{date}";
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined.");
        url_ = url_.replace("{date}", encodeURIComponent("" + date));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processFitbitLoadDate(_response));
        });
    }

    protected processFitbitLoadDate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export interface IContainerClient {

    addContainer(container: ContainerDto): Promise<BoolResponse>;

    updateContainer(container: ContainerDto): Promise<BoolResponse>;

    getAllContainers(): Promise<ContainerDto[]>;

    getContainerDropdownOptions(): Promise<IntSelectOptionDto[]>;

    checkContainerExists(container: ContainerDto): Promise<BoolResponse>;

    getContainer(containerId: number): Promise<ContainerDto>;

    searchContainerItems(request: SearchContainerItemsRequest): Promise<ContainerItemDto[]>;

    addContainerItem(item: ContainerItemDto): Promise<BoolResponse>;

    updateContainerItem(item: ContainerItemDto): Promise<BoolResponse>;

    getItemCategories(request: CategoryRequest): Promise<string[]>;

    getItemSubCategories(request: CategoryRequest): Promise<string[]>;

    getContainerItems(containerId: number): Promise<ContainerItemDto[]>;

    decrementItemQuantity(itemId: number, amount: number): Promise<BoolResponse>;

    incrementItemQuantity(itemId: number, amount: number): Promise<BoolResponse>;

    setItemQuantity(itemId: number, quantity: number): Promise<BoolResponse>;
}

export class ContainerClient extends NlpBaseClient implements IContainerClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    addContainer(container: ContainerDto): Promise<BoolResponse> {
        let url_ = this.baseUrl + "/Container/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(container);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddContainer(_response));
        });
    }

    protected processAddContainer(response: Response): Promise<BoolResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoolResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BoolResponse>(null as any);
    }

    updateContainer(container: ContainerDto): Promise<BoolResponse> {
        let url_ = this.baseUrl + "/Container/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(container);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateContainer(_response));
        });
    }

    protected processUpdateContainer(response: Response): Promise<BoolResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoolResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BoolResponse>(null as any);
    }

    getAllContainers(): Promise<ContainerDto[]> {
        let url_ = this.baseUrl + "/Container/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllContainers(_response));
        });
    }

    protected processGetAllContainers(response: Response): Promise<ContainerDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContainerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContainerDto[]>(null as any);
    }

    getContainerDropdownOptions(): Promise<IntSelectOptionDto[]> {
        let url_ = this.baseUrl + "/Container/list/as-dropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetContainerDropdownOptions(_response));
        });
    }

    protected processGetContainerDropdownOptions(response: Response): Promise<IntSelectOptionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IntSelectOptionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IntSelectOptionDto[]>(null as any);
    }

    checkContainerExists(container: ContainerDto): Promise<BoolResponse> {
        let url_ = this.baseUrl + "/Container/exists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(container);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCheckContainerExists(_response));
        });
    }

    protected processCheckContainerExists(response: Response): Promise<BoolResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoolResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BoolResponse>(null as any);
    }

    getContainer(containerId: number): Promise<ContainerDto> {
        let url_ = this.baseUrl + "/Container/id/{containerId}";
        if (containerId === undefined || containerId === null)
            throw new Error("The parameter 'containerId' must be defined.");
        url_ = url_.replace("{containerId}", encodeURIComponent("" + containerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetContainer(_response));
        });
    }

    protected processGetContainer(response: Response): Promise<ContainerDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContainerDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContainerDto>(null as any);
    }

    searchContainerItems(request: SearchContainerItemsRequest): Promise<ContainerItemDto[]> {
        let url_ = this.baseUrl + "/Container";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSearchContainerItems(_response));
        });
    }

    protected processSearchContainerItems(response: Response): Promise<ContainerItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContainerItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContainerItemDto[]>(null as any);
    }

    addContainerItem(item: ContainerItemDto): Promise<BoolResponse> {
        let url_ = this.baseUrl + "/Container/items/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddContainerItem(_response));
        });
    }

    protected processAddContainerItem(response: Response): Promise<BoolResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoolResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BoolResponse>(null as any);
    }

    updateContainerItem(item: ContainerItemDto): Promise<BoolResponse> {
        let url_ = this.baseUrl + "/Container/items/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateContainerItem(_response));
        });
    }

    protected processUpdateContainerItem(response: Response): Promise<BoolResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoolResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BoolResponse>(null as any);
    }

    getItemCategories(request: CategoryRequest): Promise<string[]> {
        let url_ = this.baseUrl + "/Container/item/categories/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetItemCategories(_response));
        });
    }

    protected processGetItemCategories(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    getItemSubCategories(request: CategoryRequest): Promise<string[]> {
        let url_ = this.baseUrl + "/Container/item/sub-categories/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetItemSubCategories(_response));
        });
    }

    protected processGetItemSubCategories(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    getContainerItems(containerId: number): Promise<ContainerItemDto[]> {
        let url_ = this.baseUrl + "/Container/items/container-id/{containerId}";
        if (containerId === undefined || containerId === null)
            throw new Error("The parameter 'containerId' must be defined.");
        url_ = url_.replace("{containerId}", encodeURIComponent("" + containerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetContainerItems(_response));
        });
    }

    protected processGetContainerItems(response: Response): Promise<ContainerItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContainerItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContainerItemDto[]>(null as any);
    }

    decrementItemQuantity(itemId: number, amount: number): Promise<BoolResponse> {
        let url_ = this.baseUrl + "/Container/item/id/{itemId}/decrement/{amount}";
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        if (amount === undefined || amount === null)
            throw new Error("The parameter 'amount' must be defined.");
        url_ = url_.replace("{amount}", encodeURIComponent("" + amount));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDecrementItemQuantity(_response));
        });
    }

    protected processDecrementItemQuantity(response: Response): Promise<BoolResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoolResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BoolResponse>(null as any);
    }

    incrementItemQuantity(itemId: number, amount: number): Promise<BoolResponse> {
        let url_ = this.baseUrl + "/Container/item/id/{itemId}/increment/{amount}";
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        if (amount === undefined || amount === null)
            throw new Error("The parameter 'amount' must be defined.");
        url_ = url_.replace("{amount}", encodeURIComponent("" + amount));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processIncrementItemQuantity(_response));
        });
    }

    protected processIncrementItemQuantity(response: Response): Promise<BoolResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoolResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BoolResponse>(null as any);
    }

    setItemQuantity(itemId: number, quantity: number): Promise<BoolResponse> {
        let url_ = this.baseUrl + "/Container/item/id/{itemId}/set-qty/{quantity}";
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        if (quantity === undefined || quantity === null)
            throw new Error("The parameter 'quantity' must be defined.");
        url_ = url_.replace("{quantity}", encodeURIComponent("" + quantity));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSetItemQuantity(_response));
        });
    }

    protected processSetItemQuantity(response: Response): Promise<BoolResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoolResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BoolResponse>(null as any);
    }
}

export interface IGameLocationsClient {

    getPlatformLocations(platformId: number): Promise<GameLocationDto[]>;

    setGameLocation(gameId: number, locationId: number): Promise<number>;

    addLocation(gameLocation: GameLocationDto): Promise<GameLocationDto>;
}

export class GameLocationsClient extends NlpBaseClient implements IGameLocationsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getPlatformLocations(platformId: number): Promise<GameLocationDto[]> {
        let url_ = this.baseUrl + "/GameLocations/list/platform-id/{platformId}";
        if (platformId === undefined || platformId === null)
            throw new Error("The parameter 'platformId' must be defined.");
        url_ = url_.replace("{platformId}", encodeURIComponent("" + platformId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPlatformLocations(_response));
        });
    }

    protected processGetPlatformLocations(response: Response): Promise<GameLocationDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GameLocationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameLocationDto[]>(null as any);
    }

    setGameLocation(gameId: number, locationId: number): Promise<number> {
        let url_ = this.baseUrl + "/GameLocations/set-location/game-id/{gameId}/location-id/{locationId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        if (locationId === undefined || locationId === null)
            throw new Error("The parameter 'locationId' must be defined.");
        url_ = url_.replace("{locationId}", encodeURIComponent("" + locationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSetGameLocation(_response));
        });
    }

    protected processSetGameLocation(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    addLocation(gameLocation: GameLocationDto): Promise<GameLocationDto> {
        let url_ = this.baseUrl + "/GameLocations/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(gameLocation);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddLocation(_response));
        });
    }

    protected processAddLocation(response: Response): Promise<GameLocationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameLocationDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameLocationDto>(null as any);
    }
}

export interface IGamePlatformsClient {

    getAll(): Promise<GamePlatformDto[]>;
}

export class GamePlatformsClient extends NlpBaseClient implements IGamePlatformsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(): Promise<GamePlatformDto[]> {
        let url_ = this.baseUrl + "/GamePlatforms/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAll(_response));
        });
    }

    protected processGetAll(response: Response): Promise<GamePlatformDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GamePlatformDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GamePlatformDto[]>(null as any);
    }
}

export interface IGameReceiptClient {

    getOrderInformation(receiptId: number): Promise<GameReceiptDto>;

    updateReceipt(gameReceipt: GameReceiptDto): Promise<GameReceiptDto>;

    addReceipt(gameId: number): Promise<GameReceiptDto>;

    search(term: string): Promise<GameReceiptDto[]>;

    associateReceiptToGame(gameId: number, receiptId: number): Promise<GameReceiptDto>;
}

export class GameReceiptClient extends NlpBaseClient implements IGameReceiptClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getOrderInformation(receiptId: number): Promise<GameReceiptDto> {
        let url_ = this.baseUrl + "/GameReceipt/order-info/{receiptId}";
        if (receiptId === undefined || receiptId === null)
            throw new Error("The parameter 'receiptId' must be defined.");
        url_ = url_.replace("{receiptId}", encodeURIComponent("" + receiptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetOrderInformation(_response));
        });
    }

    protected processGetOrderInformation(response: Response): Promise<GameReceiptDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameReceiptDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameReceiptDto>(null as any);
    }

    updateReceipt(gameReceipt: GameReceiptDto): Promise<GameReceiptDto> {
        let url_ = this.baseUrl + "/GameReceipt/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(gameReceipt);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateReceipt(_response));
        });
    }

    protected processUpdateReceipt(response: Response): Promise<GameReceiptDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameReceiptDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameReceiptDto>(null as any);
    }

    addReceipt(gameId: number): Promise<GameReceiptDto> {
        let url_ = this.baseUrl + "/GameReceipt/create/game-id/{gameId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddReceipt(_response));
        });
    }

    protected processAddReceipt(response: Response): Promise<GameReceiptDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameReceiptDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameReceiptDto>(null as any);
    }

    search(term: string): Promise<GameReceiptDto[]> {
        let url_ = this.baseUrl + "/GameReceipt/search/term/{term}";
        if (term === undefined || term === null)
            throw new Error("The parameter 'term' must be defined.");
        url_ = url_.replace("{term}", encodeURIComponent("" + term));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSearch(_response));
        });
    }

    protected processSearch(response: Response): Promise<GameReceiptDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GameReceiptDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameReceiptDto[]>(null as any);
    }

    associateReceiptToGame(gameId: number, receiptId: number): Promise<GameReceiptDto> {
        let url_ = this.baseUrl + "/GameReceipt/associate/game-id/{gameId}/receipt-id/{receiptId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        if (receiptId === undefined || receiptId === null)
            throw new Error("The parameter 'receiptId' must be defined.");
        url_ = url_.replace("{receiptId}", encodeURIComponent("" + receiptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAssociateReceiptToGame(_response));
        });
    }

    protected processAssociateReceiptToGame(response: Response): Promise<GameReceiptDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameReceiptDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameReceiptDto>(null as any);
    }
}

export interface IGamesClient {

    getPlatformGames(platformId: number): Promise<BasicGameInfoDto[]>;

    update(game: BasicGameInfoDto): Promise<BasicGameInfoDto>;

    addGame(game: BasicGameInfoDto): Promise<boolean>;
}

export class GamesClient extends NlpBaseClient implements IGamesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getPlatformGames(platformId: number): Promise<BasicGameInfoDto[]> {
        let url_ = this.baseUrl + "/Games/platform/{platformId}";
        if (platformId === undefined || platformId === null)
            throw new Error("The parameter 'platformId' must be defined.");
        url_ = url_.replace("{platformId}", encodeURIComponent("" + platformId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPlatformGames(_response));
        });
    }

    protected processGetPlatformGames(response: Response): Promise<BasicGameInfoDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BasicGameInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BasicGameInfoDto[]>(null as any);
    }

    update(game: BasicGameInfoDto): Promise<BasicGameInfoDto> {
        let url_ = this.baseUrl + "/Games/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(game);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: Response): Promise<BasicGameInfoDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BasicGameInfoDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BasicGameInfoDto>(null as any);
    }

    addGame(game: BasicGameInfoDto): Promise<boolean> {
        let url_ = this.baseUrl + "/Games/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(game);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddGame(_response));
        });
    }

    protected processAddGame(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export interface IGitHubClient {

    triggerRepoIndex(): Promise<string>;

    listRepos(): Promise<GitHubRepoDto[]>;
}

export class GitHubClient extends NlpBaseClient implements IGitHubClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    triggerRepoIndex(): Promise<string> {
        let url_ = this.baseUrl + "/api/GitHub/trigger-index";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTriggerRepoIndex(_response));
        });
    }

    protected processTriggerRepoIndex(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    listRepos(): Promise<GitHubRepoDto[]> {
        let url_ = this.baseUrl + "/api/GitHub/repo/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processListRepos(_response));
        });
    }

    protected processListRepos(response: Response): Promise<GitHubRepoDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GitHubRepoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GitHubRepoDto[]>(null as any);
    }
}

export interface IImagesClient {

    getImage(path: string): Promise<FileResponse | null>;

    getImage2(platform: string, gameId: number): Promise<FileResponse | null>;

    getGameImages(gameId: number): Promise<ImageDto[]>;
}

export class ImagesClient extends NlpBaseClient implements IImagesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getImage(path: string): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Images/link/{path}";
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetImage(_response));
        });
    }

    protected processGetImage(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    getImage2(platform: string, gameId: number): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Images/game/cover/{platform}/{gameId}";
        if (platform === undefined || platform === null)
            throw new Error("The parameter 'platform' must be defined.");
        url_ = url_.replace("{platform}", encodeURIComponent("" + platform));
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetImage2(_response));
        });
    }

    protected processGetImage2(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    getGameImages(gameId: number): Promise<ImageDto[]> {
        let url_ = this.baseUrl + "/api/Images/game/images/{gameId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetGameImages(_response));
        });
    }

    protected processGetGameImages(response: Response): Promise<ImageDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ImageDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImageDto[]>(null as any);
    }
}

export interface INetworkClient {

    getAllDevices(): Promise<NetworkDeviceDto[]>;

    addDevice(request: AddNetworkDeviceRequest): Promise<BoolResponse>;

    classifyDevice(request: ClassifyNetworkDeviceRequest): Promise<BoolResponse>;

    addIPv4Address(request: AddNetworkIPv4Request): Promise<BoolResponse>;
}

export class NetworkClient extends NlpBaseClient implements INetworkClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllDevices(): Promise<NetworkDeviceDto[]> {
        let url_ = this.baseUrl + "/Network/devices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllDevices(_response));
        });
    }

    protected processGetAllDevices(response: Response): Promise<NetworkDeviceDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NetworkDeviceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NetworkDeviceDto[]>(null as any);
    }

    addDevice(request: AddNetworkDeviceRequest): Promise<BoolResponse> {
        let url_ = this.baseUrl + "/Network/add-device";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddDevice(_response));
        });
    }

    protected processAddDevice(response: Response): Promise<BoolResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoolResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BoolResponse>(null as any);
    }

    classifyDevice(request: ClassifyNetworkDeviceRequest): Promise<BoolResponse> {
        let url_ = this.baseUrl + "/Network/device/classify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processClassifyDevice(_response));
        });
    }

    protected processClassifyDevice(response: Response): Promise<BoolResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoolResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BoolResponse>(null as any);
    }

    addIPv4Address(request: AddNetworkIPv4Request): Promise<BoolResponse> {
        let url_ = this.baseUrl + "/Network/device/add-ipv4";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddIPv4Address(_response));
        });
    }

    protected processAddIPv4Address(response: Response): Promise<BoolResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoolResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BoolResponse>(null as any);
    }
}

export interface IUserLinksClient {

    getAllLinks(): Promise<UserLinkDto[]>;

    recordLinkFollow(linkId: number): Promise<boolean>;
}

export class UserLinksClient extends NlpBaseClient implements IUserLinksClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllLinks(): Promise<UserLinkDto[]> {
        let url_ = this.baseUrl + "/api/UserLinks/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllLinks(_response));
        });
    }

    protected processGetAllLinks(response: Response): Promise<UserLinkDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserLinkDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserLinkDto[]>(null as any);
    }

    recordLinkFollow(linkId: number): Promise<boolean> {
        let url_ = this.baseUrl + "/api/UserLinks/follow/{linkId}";
        if (linkId === undefined || linkId === null)
            throw new Error("The parameter 'linkId' must be defined.");
        url_ = url_.replace("{linkId}", encodeURIComponent("" + linkId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRecordLinkFollow(_response));
        });
    }

    protected processRecordLinkFollow(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export interface IUserTasksClient {

    getAllTasks(): Promise<UserTaskDto[]>;

    addTask(task: UserTaskDto): Promise<boolean>;
}

export class UserTasksClient extends NlpBaseClient implements IUserTasksClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllTasks(): Promise<UserTaskDto[]> {
        let url_ = this.baseUrl + "/api/UserTasks/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllTasks(_response));
        });
    }

    protected processGetAllTasks(response: Response): Promise<UserTaskDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserTaskDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserTaskDto[]>(null as any);
    }

    addTask(task: UserTaskDto): Promise<boolean> {
        let url_ = this.baseUrl + "/api/UserTasks/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(task);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddTask(_response));
        });
    }

    protected processAddTask(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class WhoAmIResponse implements IWhoAmIResponse {
    name?: string | null;
    email?: string | null;
    signedIn!: boolean;
    claims?: { [key: string]: string; } | null;

    constructor(data?: IWhoAmIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.signedIn = _data["signedIn"] !== undefined ? _data["signedIn"] : <any>null;
            if (_data["claims"]) {
                this.claims = {} as any;
                for (let key in _data["claims"]) {
                    if (_data["claims"].hasOwnProperty(key))
                        (<any>this.claims)![key] = _data["claims"][key] !== undefined ? _data["claims"][key] : <any>null;
                }
            }
            else {
                this.claims = <any>null;
            }
        }
    }

    static fromJS(data: any): WhoAmIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WhoAmIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["signedIn"] = this.signedIn !== undefined ? this.signedIn : <any>null;
        if (this.claims) {
            data["claims"] = {};
            for (let key in this.claims) {
                if (this.claims.hasOwnProperty(key))
                    (<any>data["claims"])[key] = this.claims[key] !== undefined ? this.claims[key] : <any>null;
            }
        }
        return data;
    }
}

export interface IWhoAmIResponse {
    name?: string | null;
    email?: string | null;
    signedIn: boolean;
    claims?: { [key: string]: string; } | null;
}

export class SetNewPasswordRequest implements ISetNewPasswordRequest {
    email!: string;
    password!: string;

    constructor(data?: ISetNewPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): SetNewPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetNewPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface ISetNewPasswordRequest {
    email: string;
    password: string;
}

export class BoolResponse implements IBoolResponse {
    success!: boolean;
    error?: string | null;

    constructor(data?: IBoolResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
        }
    }

    static fromJS(data: any): BoolResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BoolResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        return data;
    }
}

export interface IBoolResponse {
    success: boolean;
    error?: string | null;
}

export class ContainerDto implements IContainerDto {
    containerId!: number;
    shelfNumber!: number;
    shelfLevel!: number;
    shelfRow!: number;
    shelfRowPosition!: number;
    itemCount!: number;
    containerLabel!: string;
    containerName!: string;
    notes!: string;

    constructor(data?: IContainerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.containerId = _data["containerId"] !== undefined ? _data["containerId"] : <any>null;
            this.shelfNumber = _data["shelfNumber"] !== undefined ? _data["shelfNumber"] : <any>null;
            this.shelfLevel = _data["shelfLevel"] !== undefined ? _data["shelfLevel"] : <any>null;
            this.shelfRow = _data["shelfRow"] !== undefined ? _data["shelfRow"] : <any>null;
            this.shelfRowPosition = _data["shelfRowPosition"] !== undefined ? _data["shelfRowPosition"] : <any>null;
            this.itemCount = _data["itemCount"] !== undefined ? _data["itemCount"] : <any>null;
            this.containerLabel = _data["containerLabel"] !== undefined ? _data["containerLabel"] : <any>null;
            this.containerName = _data["containerName"] !== undefined ? _data["containerName"] : <any>null;
            this.notes = _data["notes"] !== undefined ? _data["notes"] : <any>null;
        }
    }

    static fromJS(data: any): ContainerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["containerId"] = this.containerId !== undefined ? this.containerId : <any>null;
        data["shelfNumber"] = this.shelfNumber !== undefined ? this.shelfNumber : <any>null;
        data["shelfLevel"] = this.shelfLevel !== undefined ? this.shelfLevel : <any>null;
        data["shelfRow"] = this.shelfRow !== undefined ? this.shelfRow : <any>null;
        data["shelfRowPosition"] = this.shelfRowPosition !== undefined ? this.shelfRowPosition : <any>null;
        data["itemCount"] = this.itemCount !== undefined ? this.itemCount : <any>null;
        data["containerLabel"] = this.containerLabel !== undefined ? this.containerLabel : <any>null;
        data["containerName"] = this.containerName !== undefined ? this.containerName : <any>null;
        data["notes"] = this.notes !== undefined ? this.notes : <any>null;
        return data;
    }
}

export interface IContainerDto {
    containerId: number;
    shelfNumber: number;
    shelfLevel: number;
    shelfRow: number;
    shelfRowPosition: number;
    itemCount: number;
    containerLabel: string;
    containerName: string;
    notes: string;
}

export class IntSelectOptionDto implements IIntSelectOptionDto {
    value!: number;
    title!: string;

    constructor(data?: IIntSelectOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
        }
    }

    static fromJS(data: any): IntSelectOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new IntSelectOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        return data;
    }
}

export interface IIntSelectOptionDto {
    value: number;
    title: string;
}

export class ContainerItemDto extends ContainerDto implements IContainerItemDto {
    itemId!: number;
    containerId!: number;
    quantity!: number;
    orderMoreMinQty!: number;
    orderMore!: boolean;
    orderPlaced!: boolean;
    autoFlagOrderMore!: boolean;
    category!: string;
    subCategory!: string;
    inventoryName!: string;
    orderUrl!: string;

    constructor(data?: IContainerItemDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.itemId = _data["itemId"] !== undefined ? _data["itemId"] : <any>null;
            this.containerId = _data["containerId"] !== undefined ? _data["containerId"] : <any>null;
            this.quantity = _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
            this.orderMoreMinQty = _data["orderMoreMinQty"] !== undefined ? _data["orderMoreMinQty"] : <any>null;
            this.orderMore = _data["orderMore"] !== undefined ? _data["orderMore"] : <any>null;
            this.orderPlaced = _data["orderPlaced"] !== undefined ? _data["orderPlaced"] : <any>null;
            this.autoFlagOrderMore = _data["autoFlagOrderMore"] !== undefined ? _data["autoFlagOrderMore"] : <any>null;
            this.category = _data["category"] !== undefined ? _data["category"] : <any>null;
            this.subCategory = _data["subCategory"] !== undefined ? _data["subCategory"] : <any>null;
            this.inventoryName = _data["inventoryName"] !== undefined ? _data["inventoryName"] : <any>null;
            this.orderUrl = _data["orderUrl"] !== undefined ? _data["orderUrl"] : <any>null;
        }
    }

    static override fromJS(data: any): ContainerItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerItemDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId !== undefined ? this.itemId : <any>null;
        data["containerId"] = this.containerId !== undefined ? this.containerId : <any>null;
        data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        data["orderMoreMinQty"] = this.orderMoreMinQty !== undefined ? this.orderMoreMinQty : <any>null;
        data["orderMore"] = this.orderMore !== undefined ? this.orderMore : <any>null;
        data["orderPlaced"] = this.orderPlaced !== undefined ? this.orderPlaced : <any>null;
        data["autoFlagOrderMore"] = this.autoFlagOrderMore !== undefined ? this.autoFlagOrderMore : <any>null;
        data["category"] = this.category !== undefined ? this.category : <any>null;
        data["subCategory"] = this.subCategory !== undefined ? this.subCategory : <any>null;
        data["inventoryName"] = this.inventoryName !== undefined ? this.inventoryName : <any>null;
        data["orderUrl"] = this.orderUrl !== undefined ? this.orderUrl : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IContainerItemDto extends IContainerDto {
    itemId: number;
    containerId: number;
    quantity: number;
    orderMoreMinQty: number;
    orderMore: boolean;
    orderPlaced: boolean;
    autoFlagOrderMore: boolean;
    category: string;
    subCategory: string;
    inventoryName: string;
    orderUrl: string;
}

export class SearchContainerItemsRequest implements ISearchContainerItemsRequest {
    category?: string | null;
    subCategory?: string | null;
    term!: string;

    constructor(data?: ISearchContainerItemsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"] !== undefined ? _data["category"] : <any>null;
            this.subCategory = _data["subCategory"] !== undefined ? _data["subCategory"] : <any>null;
            this.term = _data["term"] !== undefined ? _data["term"] : <any>null;
        }
    }

    static fromJS(data: any): SearchContainerItemsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchContainerItemsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category !== undefined ? this.category : <any>null;
        data["subCategory"] = this.subCategory !== undefined ? this.subCategory : <any>null;
        data["term"] = this.term !== undefined ? this.term : <any>null;
        return data;
    }
}

export interface ISearchContainerItemsRequest {
    category?: string | null;
    subCategory?: string | null;
    term: string;
}

export class CategoryRequest implements ICategoryRequest {
    category!: string;
    subCategory!: string;

    constructor(data?: ICategoryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"] !== undefined ? _data["category"] : <any>null;
            this.subCategory = _data["subCategory"] !== undefined ? _data["subCategory"] : <any>null;
        }
    }

    static fromJS(data: any): CategoryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category !== undefined ? this.category : <any>null;
        data["subCategory"] = this.subCategory !== undefined ? this.subCategory : <any>null;
        return data;
    }
}

export interface ICategoryRequest {
    category: string;
    subCategory: string;
}

export class GameLocationDto implements IGameLocationDto {
    locationID!: number;
    platformID!: number;
    locationName!: string;

    constructor(data?: IGameLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationID = _data["locationID"] !== undefined ? _data["locationID"] : <any>null;
            this.platformID = _data["platformID"] !== undefined ? _data["platformID"] : <any>null;
            this.locationName = _data["locationName"] !== undefined ? _data["locationName"] : <any>null;
        }
    }

    static fromJS(data: any): GameLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new GameLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationID"] = this.locationID !== undefined ? this.locationID : <any>null;
        data["platformID"] = this.platformID !== undefined ? this.platformID : <any>null;
        data["locationName"] = this.locationName !== undefined ? this.locationName : <any>null;
        return data;
    }
}

export interface IGameLocationDto {
    locationID: number;
    platformID: number;
    locationName: string;
}

export class GamePlatformDto implements IGamePlatformDto {
    platformID!: number;
    platformName!: string;

    constructor(data?: IGamePlatformDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.platformID = _data["platformID"] !== undefined ? _data["platformID"] : <any>null;
            this.platformName = _data["platformName"] !== undefined ? _data["platformName"] : <any>null;
        }
    }

    static fromJS(data: any): GamePlatformDto {
        data = typeof data === 'object' ? data : {};
        let result = new GamePlatformDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["platformID"] = this.platformID !== undefined ? this.platformID : <any>null;
        data["platformName"] = this.platformName !== undefined ? this.platformName : <any>null;
        return data;
    }
}

export interface IGamePlatformDto {
    platformID: number;
    platformName: string;
}

export class GameReceiptDto implements IGameReceiptDto {
    receiptID!: number;
    store!: string;
    receiptNumber!: string;
    receiptDate!: Date;
    receiptName!: string;
    receiptUrl!: string;
    receiptScanned!: boolean;

    constructor(data?: IGameReceiptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiptID = _data["receiptID"] !== undefined ? _data["receiptID"] : <any>null;
            this.store = _data["store"] !== undefined ? _data["store"] : <any>null;
            this.receiptNumber = _data["receiptNumber"] !== undefined ? _data["receiptNumber"] : <any>null;
            this.receiptDate = _data["receiptDate"] ? new Date(_data["receiptDate"].toString()) : <any>null;
            this.receiptName = _data["receiptName"] !== undefined ? _data["receiptName"] : <any>null;
            this.receiptUrl = _data["receiptUrl"] !== undefined ? _data["receiptUrl"] : <any>null;
            this.receiptScanned = _data["receiptScanned"] !== undefined ? _data["receiptScanned"] : <any>null;
        }
    }

    static fromJS(data: any): GameReceiptDto {
        data = typeof data === 'object' ? data : {};
        let result = new GameReceiptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiptID"] = this.receiptID !== undefined ? this.receiptID : <any>null;
        data["store"] = this.store !== undefined ? this.store : <any>null;
        data["receiptNumber"] = this.receiptNumber !== undefined ? this.receiptNumber : <any>null;
        data["receiptDate"] = this.receiptDate ? this.receiptDate.toISOString() : <any>null;
        data["receiptName"] = this.receiptName !== undefined ? this.receiptName : <any>null;
        data["receiptUrl"] = this.receiptUrl !== undefined ? this.receiptUrl : <any>null;
        data["receiptScanned"] = this.receiptScanned !== undefined ? this.receiptScanned : <any>null;
        return data;
    }
}

export interface IGameReceiptDto {
    receiptID: number;
    store: string;
    receiptNumber: string;
    receiptDate: Date;
    receiptName: string;
    receiptUrl: string;
    receiptScanned: boolean;
}

export class BasicGameInfoDto implements IBasicGameInfoDto {
    gameID!: number;
    gameName!: string;
    platformID!: number;
    locationID!: number;
    gameCaseLocation!: string;
    hasGameBox!: boolean;
    gameRating!: number;
    imagePath!: string;
    locationName!: string;
    platformName!: string;
    hasProtection!: boolean;
    store!: string;
    receiptNumber!: string;
    gamePrice!: number;
    receiptDate?: Date | null;
    gameSold!: boolean;
    hasReceipt!: boolean;
    receiptName!: string;
    receiptScanned!: boolean;
    receiptID!: number;
    searchTerm!: string;

    constructor(data?: IBasicGameInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gameID = _data["gameID"] !== undefined ? _data["gameID"] : <any>null;
            this.gameName = _data["gameName"] !== undefined ? _data["gameName"] : <any>null;
            this.platformID = _data["platformID"] !== undefined ? _data["platformID"] : <any>null;
            this.locationID = _data["locationID"] !== undefined ? _data["locationID"] : <any>null;
            this.gameCaseLocation = _data["gameCaseLocation"] !== undefined ? _data["gameCaseLocation"] : <any>null;
            this.hasGameBox = _data["hasGameBox"] !== undefined ? _data["hasGameBox"] : <any>null;
            this.gameRating = _data["gameRating"] !== undefined ? _data["gameRating"] : <any>null;
            this.imagePath = _data["imagePath"] !== undefined ? _data["imagePath"] : <any>null;
            this.locationName = _data["locationName"] !== undefined ? _data["locationName"] : <any>null;
            this.platformName = _data["platformName"] !== undefined ? _data["platformName"] : <any>null;
            this.hasProtection = _data["hasProtection"] !== undefined ? _data["hasProtection"] : <any>null;
            this.store = _data["store"] !== undefined ? _data["store"] : <any>null;
            this.receiptNumber = _data["receiptNumber"] !== undefined ? _data["receiptNumber"] : <any>null;
            this.gamePrice = _data["gamePrice"] !== undefined ? _data["gamePrice"] : <any>null;
            this.receiptDate = _data["receiptDate"] ? new Date(_data["receiptDate"].toString()) : <any>null;
            this.gameSold = _data["gameSold"] !== undefined ? _data["gameSold"] : <any>null;
            this.hasReceipt = _data["hasReceipt"] !== undefined ? _data["hasReceipt"] : <any>null;
            this.receiptName = _data["receiptName"] !== undefined ? _data["receiptName"] : <any>null;
            this.receiptScanned = _data["receiptScanned"] !== undefined ? _data["receiptScanned"] : <any>null;
            this.receiptID = _data["receiptID"] !== undefined ? _data["receiptID"] : <any>null;
            this.searchTerm = _data["searchTerm"] !== undefined ? _data["searchTerm"] : <any>null;
        }
    }

    static fromJS(data: any): BasicGameInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BasicGameInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameID"] = this.gameID !== undefined ? this.gameID : <any>null;
        data["gameName"] = this.gameName !== undefined ? this.gameName : <any>null;
        data["platformID"] = this.platformID !== undefined ? this.platformID : <any>null;
        data["locationID"] = this.locationID !== undefined ? this.locationID : <any>null;
        data["gameCaseLocation"] = this.gameCaseLocation !== undefined ? this.gameCaseLocation : <any>null;
        data["hasGameBox"] = this.hasGameBox !== undefined ? this.hasGameBox : <any>null;
        data["gameRating"] = this.gameRating !== undefined ? this.gameRating : <any>null;
        data["imagePath"] = this.imagePath !== undefined ? this.imagePath : <any>null;
        data["locationName"] = this.locationName !== undefined ? this.locationName : <any>null;
        data["platformName"] = this.platformName !== undefined ? this.platformName : <any>null;
        data["hasProtection"] = this.hasProtection !== undefined ? this.hasProtection : <any>null;
        data["store"] = this.store !== undefined ? this.store : <any>null;
        data["receiptNumber"] = this.receiptNumber !== undefined ? this.receiptNumber : <any>null;
        data["gamePrice"] = this.gamePrice !== undefined ? this.gamePrice : <any>null;
        data["receiptDate"] = this.receiptDate ? this.receiptDate.toISOString() : <any>null;
        data["gameSold"] = this.gameSold !== undefined ? this.gameSold : <any>null;
        data["hasReceipt"] = this.hasReceipt !== undefined ? this.hasReceipt : <any>null;
        data["receiptName"] = this.receiptName !== undefined ? this.receiptName : <any>null;
        data["receiptScanned"] = this.receiptScanned !== undefined ? this.receiptScanned : <any>null;
        data["receiptID"] = this.receiptID !== undefined ? this.receiptID : <any>null;
        data["searchTerm"] = this.searchTerm !== undefined ? this.searchTerm : <any>null;
        return data;
    }
}

export interface IBasicGameInfoDto {
    gameID: number;
    gameName: string;
    platformID: number;
    locationID: number;
    gameCaseLocation: string;
    hasGameBox: boolean;
    gameRating: number;
    imagePath: string;
    locationName: string;
    platformName: string;
    hasProtection: boolean;
    store: string;
    receiptNumber: string;
    gamePrice: number;
    receiptDate?: Date | null;
    gameSold: boolean;
    hasReceipt: boolean;
    receiptName: string;
    receiptScanned: boolean;
    receiptID: number;
    searchTerm: string;
}

export class GitHubRepoDto implements IGitHubRepoDto {
    repoID!: number;
    repoSize!: number;
    isTemplate!: boolean;
    isPrivate!: boolean;
    isFork!: boolean;
    hasIssues!: boolean;
    hasWiki!: boolean;
    hasDownloads!: boolean;
    hasPages!: boolean;
    isArchived!: boolean;
    forksCount!: number;
    stargazersCount!: number;
    openIssuesCount!: number;
    subscribersCount!: number;
    pushedAt?: Date | null;
    createdAt!: Date;
    updatedAt!: Date;
    license!: string;
    defaultBranch!: string;
    gitUrl!: string;
    sshUrl!: string;
    name!: string;
    fullName!: string;
    description!: string;

    constructor(data?: IGitHubRepoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.repoID = _data["repoID"] !== undefined ? _data["repoID"] : <any>null;
            this.repoSize = _data["repoSize"] !== undefined ? _data["repoSize"] : <any>null;
            this.isTemplate = _data["isTemplate"] !== undefined ? _data["isTemplate"] : <any>null;
            this.isPrivate = _data["isPrivate"] !== undefined ? _data["isPrivate"] : <any>null;
            this.isFork = _data["isFork"] !== undefined ? _data["isFork"] : <any>null;
            this.hasIssues = _data["hasIssues"] !== undefined ? _data["hasIssues"] : <any>null;
            this.hasWiki = _data["hasWiki"] !== undefined ? _data["hasWiki"] : <any>null;
            this.hasDownloads = _data["hasDownloads"] !== undefined ? _data["hasDownloads"] : <any>null;
            this.hasPages = _data["hasPages"] !== undefined ? _data["hasPages"] : <any>null;
            this.isArchived = _data["isArchived"] !== undefined ? _data["isArchived"] : <any>null;
            this.forksCount = _data["forksCount"] !== undefined ? _data["forksCount"] : <any>null;
            this.stargazersCount = _data["stargazersCount"] !== undefined ? _data["stargazersCount"] : <any>null;
            this.openIssuesCount = _data["openIssuesCount"] !== undefined ? _data["openIssuesCount"] : <any>null;
            this.subscribersCount = _data["subscribersCount"] !== undefined ? _data["subscribersCount"] : <any>null;
            this.pushedAt = _data["pushedAt"] ? new Date(_data["pushedAt"].toString()) : <any>null;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>null;
            this.license = _data["license"] !== undefined ? _data["license"] : <any>null;
            this.defaultBranch = _data["defaultBranch"] !== undefined ? _data["defaultBranch"] : <any>null;
            this.gitUrl = _data["gitUrl"] !== undefined ? _data["gitUrl"] : <any>null;
            this.sshUrl = _data["sshUrl"] !== undefined ? _data["sshUrl"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): GitHubRepoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GitHubRepoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repoID"] = this.repoID !== undefined ? this.repoID : <any>null;
        data["repoSize"] = this.repoSize !== undefined ? this.repoSize : <any>null;
        data["isTemplate"] = this.isTemplate !== undefined ? this.isTemplate : <any>null;
        data["isPrivate"] = this.isPrivate !== undefined ? this.isPrivate : <any>null;
        data["isFork"] = this.isFork !== undefined ? this.isFork : <any>null;
        data["hasIssues"] = this.hasIssues !== undefined ? this.hasIssues : <any>null;
        data["hasWiki"] = this.hasWiki !== undefined ? this.hasWiki : <any>null;
        data["hasDownloads"] = this.hasDownloads !== undefined ? this.hasDownloads : <any>null;
        data["hasPages"] = this.hasPages !== undefined ? this.hasPages : <any>null;
        data["isArchived"] = this.isArchived !== undefined ? this.isArchived : <any>null;
        data["forksCount"] = this.forksCount !== undefined ? this.forksCount : <any>null;
        data["stargazersCount"] = this.stargazersCount !== undefined ? this.stargazersCount : <any>null;
        data["openIssuesCount"] = this.openIssuesCount !== undefined ? this.openIssuesCount : <any>null;
        data["subscribersCount"] = this.subscribersCount !== undefined ? this.subscribersCount : <any>null;
        data["pushedAt"] = this.pushedAt ? this.pushedAt.toISOString() : <any>null;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>null;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>null;
        data["license"] = this.license !== undefined ? this.license : <any>null;
        data["defaultBranch"] = this.defaultBranch !== undefined ? this.defaultBranch : <any>null;
        data["gitUrl"] = this.gitUrl !== undefined ? this.gitUrl : <any>null;
        data["sshUrl"] = this.sshUrl !== undefined ? this.sshUrl : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IGitHubRepoDto {
    repoID: number;
    repoSize: number;
    isTemplate: boolean;
    isPrivate: boolean;
    isFork: boolean;
    hasIssues: boolean;
    hasWiki: boolean;
    hasDownloads: boolean;
    hasPages: boolean;
    isArchived: boolean;
    forksCount: number;
    stargazersCount: number;
    openIssuesCount: number;
    subscribersCount: number;
    pushedAt?: Date | null;
    createdAt: Date;
    updatedAt: Date;
    license: string;
    defaultBranch: string;
    gitUrl: string;
    sshUrl: string;
    name: string;
    fullName: string;
    description: string;
}

export class ImageDto implements IImageDto {
    gameID!: number;
    imageType!: string;
    imageOrder!: number;
    imagePath!: string;

    constructor(data?: IImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gameID = _data["gameID"] !== undefined ? _data["gameID"] : <any>null;
            this.imageType = _data["imageType"] !== undefined ? _data["imageType"] : <any>null;
            this.imageOrder = _data["imageOrder"] !== undefined ? _data["imageOrder"] : <any>null;
            this.imagePath = _data["imagePath"] !== undefined ? _data["imagePath"] : <any>null;
        }
    }

    static fromJS(data: any): ImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameID"] = this.gameID !== undefined ? this.gameID : <any>null;
        data["imageType"] = this.imageType !== undefined ? this.imageType : <any>null;
        data["imageOrder"] = this.imageOrder !== undefined ? this.imageOrder : <any>null;
        data["imagePath"] = this.imagePath !== undefined ? this.imagePath : <any>null;
        return data;
    }
}

export interface IImageDto {
    gameID: number;
    imageType: string;
    imageOrder: number;
    imagePath: string;
}

export class NetworkDeviceDto implements INetworkDeviceDto {
    deviceID!: number;
    isPhysical!: boolean;
    isActive!: boolean;
    deviceName!: string;
    floor?: string | null;
    room?: string | null;
    roomLocation?: string | null;
    classification?: NetworkDeviceClassificationDto | null;
    ipv4!: NetworkDeviceIPv4EntryDto[];

    constructor(data?: INetworkDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ipv4 = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceID = _data["deviceID"] !== undefined ? _data["deviceID"] : <any>null;
            this.isPhysical = _data["isPhysical"] !== undefined ? _data["isPhysical"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : <any>null;
            this.floor = _data["floor"] !== undefined ? _data["floor"] : <any>null;
            this.room = _data["room"] !== undefined ? _data["room"] : <any>null;
            this.roomLocation = _data["roomLocation"] !== undefined ? _data["roomLocation"] : <any>null;
            this.classification = _data["classification"] ? NetworkDeviceClassificationDto.fromJS(_data["classification"]) : <any>null;
            if (Array.isArray(_data["ipv4"])) {
                this.ipv4 = [] as any;
                for (let item of _data["ipv4"])
                    this.ipv4!.push(NetworkDeviceIPv4EntryDto.fromJS(item));
            }
            else {
                this.ipv4 = <any>null;
            }
        }
    }

    static fromJS(data: any): NetworkDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new NetworkDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceID"] = this.deviceID !== undefined ? this.deviceID : <any>null;
        data["isPhysical"] = this.isPhysical !== undefined ? this.isPhysical : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : <any>null;
        data["floor"] = this.floor !== undefined ? this.floor : <any>null;
        data["room"] = this.room !== undefined ? this.room : <any>null;
        data["roomLocation"] = this.roomLocation !== undefined ? this.roomLocation : <any>null;
        data["classification"] = this.classification ? this.classification.toJSON() : <any>null;
        if (Array.isArray(this.ipv4)) {
            data["ipv4"] = [];
            for (let item of this.ipv4)
                data["ipv4"].push(item.toJSON());
        }
        return data;
    }
}

export interface INetworkDeviceDto {
    deviceID: number;
    isPhysical: boolean;
    isActive: boolean;
    deviceName: string;
    floor?: string | null;
    room?: string | null;
    roomLocation?: string | null;
    classification?: NetworkDeviceClassificationDto | null;
    ipv4: NetworkDeviceIPv4EntryDto[];
}

export class NetworkDeviceClassificationDto implements INetworkDeviceClassificationDto {
    category!: string;
    subCategory?: string | null;
    manufacturer?: string | null;
    model?: string | null;

    constructor(data?: INetworkDeviceClassificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"] !== undefined ? _data["category"] : <any>null;
            this.subCategory = _data["subCategory"] !== undefined ? _data["subCategory"] : <any>null;
            this.manufacturer = _data["manufacturer"] !== undefined ? _data["manufacturer"] : <any>null;
            this.model = _data["model"] !== undefined ? _data["model"] : <any>null;
        }
    }

    static fromJS(data: any): NetworkDeviceClassificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new NetworkDeviceClassificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category !== undefined ? this.category : <any>null;
        data["subCategory"] = this.subCategory !== undefined ? this.subCategory : <any>null;
        data["manufacturer"] = this.manufacturer !== undefined ? this.manufacturer : <any>null;
        data["model"] = this.model !== undefined ? this.model : <any>null;
        return data;
    }
}

export interface INetworkDeviceClassificationDto {
    category: string;
    subCategory?: string | null;
    manufacturer?: string | null;
    model?: string | null;
}

export class NetworkDeviceIPv4EntryDto implements INetworkDeviceIPv4EntryDto {
    macAddress?: string | null;
    ipv4?: string | null;
    ipv4Int!: number;
    connection!: string;
    networkName?: string | null;

    constructor(data?: INetworkDeviceIPv4EntryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.macAddress = _data["macAddress"] !== undefined ? _data["macAddress"] : <any>null;
            this.ipv4 = _data["ipv4"] !== undefined ? _data["ipv4"] : <any>null;
            this.ipv4Int = _data["ipv4Int"] !== undefined ? _data["ipv4Int"] : <any>null;
            this.connection = _data["connection"] !== undefined ? _data["connection"] : <any>null;
            this.networkName = _data["networkName"] !== undefined ? _data["networkName"] : <any>null;
        }
    }

    static fromJS(data: any): NetworkDeviceIPv4EntryDto {
        data = typeof data === 'object' ? data : {};
        let result = new NetworkDeviceIPv4EntryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["macAddress"] = this.macAddress !== undefined ? this.macAddress : <any>null;
        data["ipv4"] = this.ipv4 !== undefined ? this.ipv4 : <any>null;
        data["ipv4Int"] = this.ipv4Int !== undefined ? this.ipv4Int : <any>null;
        data["connection"] = this.connection !== undefined ? this.connection : <any>null;
        data["networkName"] = this.networkName !== undefined ? this.networkName : <any>null;
        return data;
    }
}

export interface INetworkDeviceIPv4EntryDto {
    macAddress?: string | null;
    ipv4?: string | null;
    ipv4Int: number;
    connection: string;
    networkName?: string | null;
}

export class AddNetworkDeviceRequest implements IAddNetworkDeviceRequest {
    isPhysical!: boolean;
    deviceName!: string;
    floor?: string | null;
    room?: string | null;
    roomLocation?: string | null;

    constructor(data?: IAddNetworkDeviceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isPhysical = _data["isPhysical"] !== undefined ? _data["isPhysical"] : <any>null;
            this.deviceName = _data["deviceName"] !== undefined ? _data["deviceName"] : <any>null;
            this.floor = _data["floor"] !== undefined ? _data["floor"] : <any>null;
            this.room = _data["room"] !== undefined ? _data["room"] : <any>null;
            this.roomLocation = _data["roomLocation"] !== undefined ? _data["roomLocation"] : <any>null;
        }
    }

    static fromJS(data: any): AddNetworkDeviceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddNetworkDeviceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isPhysical"] = this.isPhysical !== undefined ? this.isPhysical : <any>null;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : <any>null;
        data["floor"] = this.floor !== undefined ? this.floor : <any>null;
        data["room"] = this.room !== undefined ? this.room : <any>null;
        data["roomLocation"] = this.roomLocation !== undefined ? this.roomLocation : <any>null;
        return data;
    }
}

export interface IAddNetworkDeviceRequest {
    isPhysical: boolean;
    deviceName: string;
    floor?: string | null;
    room?: string | null;
    roomLocation?: string | null;
}

export class ClassifyNetworkDeviceRequest implements IClassifyNetworkDeviceRequest {
    deviceID!: number;
    category!: string;
    subCategory?: string | null;
    manufacturer?: string | null;
    model?: string | null;

    constructor(data?: IClassifyNetworkDeviceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceID = _data["deviceID"] !== undefined ? _data["deviceID"] : <any>null;
            this.category = _data["category"] !== undefined ? _data["category"] : <any>null;
            this.subCategory = _data["subCategory"] !== undefined ? _data["subCategory"] : <any>null;
            this.manufacturer = _data["manufacturer"] !== undefined ? _data["manufacturer"] : <any>null;
            this.model = _data["model"] !== undefined ? _data["model"] : <any>null;
        }
    }

    static fromJS(data: any): ClassifyNetworkDeviceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ClassifyNetworkDeviceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceID"] = this.deviceID !== undefined ? this.deviceID : <any>null;
        data["category"] = this.category !== undefined ? this.category : <any>null;
        data["subCategory"] = this.subCategory !== undefined ? this.subCategory : <any>null;
        data["manufacturer"] = this.manufacturer !== undefined ? this.manufacturer : <any>null;
        data["model"] = this.model !== undefined ? this.model : <any>null;
        return data;
    }
}

export interface IClassifyNetworkDeviceRequest {
    deviceID: number;
    category: string;
    subCategory?: string | null;
    manufacturer?: string | null;
    model?: string | null;
}

export class AddNetworkIPv4Request implements IAddNetworkIPv4Request {
    deviceID!: number;
    macAddress?: string | null;
    iPv4?: string | null;
    connection!: string;
    networkName?: string | null;

    constructor(data?: IAddNetworkIPv4Request) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceID = _data["deviceID"] !== undefined ? _data["deviceID"] : <any>null;
            this.macAddress = _data["macAddress"] !== undefined ? _data["macAddress"] : <any>null;
            this.iPv4 = _data["iPv4"] !== undefined ? _data["iPv4"] : <any>null;
            this.connection = _data["connection"] !== undefined ? _data["connection"] : <any>null;
            this.networkName = _data["networkName"] !== undefined ? _data["networkName"] : <any>null;
        }
    }

    static fromJS(data: any): AddNetworkIPv4Request {
        data = typeof data === 'object' ? data : {};
        let result = new AddNetworkIPv4Request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceID"] = this.deviceID !== undefined ? this.deviceID : <any>null;
        data["macAddress"] = this.macAddress !== undefined ? this.macAddress : <any>null;
        data["iPv4"] = this.iPv4 !== undefined ? this.iPv4 : <any>null;
        data["connection"] = this.connection !== undefined ? this.connection : <any>null;
        data["networkName"] = this.networkName !== undefined ? this.networkName : <any>null;
        return data;
    }
}

export interface IAddNetworkIPv4Request {
    deviceID: number;
    macAddress?: string | null;
    iPv4?: string | null;
    connection: string;
    networkName?: string | null;
}

export class UserLinkDto implements IUserLinkDto {
    linkID!: number;
    deleted!: boolean;
    linkOrder!: number;
    followCount!: number;
    dateAddedUtc!: Date;
    dateUpdatedUtc!: Date;
    dateLastFollowedUtc!: Date;
    linkName!: string;
    linkCategory!: string;
    linkUrl!: string;
    linkImage!: string;

    constructor(data?: IUserLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linkID = _data["linkID"] !== undefined ? _data["linkID"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.linkOrder = _data["linkOrder"] !== undefined ? _data["linkOrder"] : <any>null;
            this.followCount = _data["followCount"] !== undefined ? _data["followCount"] : <any>null;
            this.dateAddedUtc = _data["dateAddedUtc"] ? new Date(_data["dateAddedUtc"].toString()) : <any>null;
            this.dateUpdatedUtc = _data["dateUpdatedUtc"] ? new Date(_data["dateUpdatedUtc"].toString()) : <any>null;
            this.dateLastFollowedUtc = _data["dateLastFollowedUtc"] ? new Date(_data["dateLastFollowedUtc"].toString()) : <any>null;
            this.linkName = _data["linkName"] !== undefined ? _data["linkName"] : <any>null;
            this.linkCategory = _data["linkCategory"] !== undefined ? _data["linkCategory"] : <any>null;
            this.linkUrl = _data["linkUrl"] !== undefined ? _data["linkUrl"] : <any>null;
            this.linkImage = _data["linkImage"] !== undefined ? _data["linkImage"] : <any>null;
        }
    }

    static fromJS(data: any): UserLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkID"] = this.linkID !== undefined ? this.linkID : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["linkOrder"] = this.linkOrder !== undefined ? this.linkOrder : <any>null;
        data["followCount"] = this.followCount !== undefined ? this.followCount : <any>null;
        data["dateAddedUtc"] = this.dateAddedUtc ? this.dateAddedUtc.toISOString() : <any>null;
        data["dateUpdatedUtc"] = this.dateUpdatedUtc ? this.dateUpdatedUtc.toISOString() : <any>null;
        data["dateLastFollowedUtc"] = this.dateLastFollowedUtc ? this.dateLastFollowedUtc.toISOString() : <any>null;
        data["linkName"] = this.linkName !== undefined ? this.linkName : <any>null;
        data["linkCategory"] = this.linkCategory !== undefined ? this.linkCategory : <any>null;
        data["linkUrl"] = this.linkUrl !== undefined ? this.linkUrl : <any>null;
        data["linkImage"] = this.linkImage !== undefined ? this.linkImage : <any>null;
        return data;
    }
}

export interface IUserLinkDto {
    linkID: number;
    deleted: boolean;
    linkOrder: number;
    followCount: number;
    dateAddedUtc: Date;
    dateUpdatedUtc: Date;
    dateLastFollowedUtc: Date;
    linkName: string;
    linkCategory: string;
    linkUrl: string;
    linkImage: string;
}

export class UserTaskDto implements IUserTaskDto {
    taskID!: number;
    deleted!: boolean;
    completed!: boolean;
    taskPriority!: number;
    dateAddedUtc!: Date;
    dateCompletedUtc!: Date;
    taskName!: string;
    taskCategory!: string;
    taskDescription!: string;

    constructor(data?: IUserTaskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskID = _data["taskID"] !== undefined ? _data["taskID"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
            this.completed = _data["completed"] !== undefined ? _data["completed"] : <any>null;
            this.taskPriority = _data["taskPriority"] !== undefined ? _data["taskPriority"] : <any>null;
            this.dateAddedUtc = _data["dateAddedUtc"] ? new Date(_data["dateAddedUtc"].toString()) : <any>null;
            this.dateCompletedUtc = _data["dateCompletedUtc"] ? new Date(_data["dateCompletedUtc"].toString()) : <any>null;
            this.taskName = _data["taskName"] !== undefined ? _data["taskName"] : <any>null;
            this.taskCategory = _data["taskCategory"] !== undefined ? _data["taskCategory"] : <any>null;
            this.taskDescription = _data["taskDescription"] !== undefined ? _data["taskDescription"] : <any>null;
        }
    }

    static fromJS(data: any): UserTaskDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserTaskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskID"] = this.taskID !== undefined ? this.taskID : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        data["completed"] = this.completed !== undefined ? this.completed : <any>null;
        data["taskPriority"] = this.taskPriority !== undefined ? this.taskPriority : <any>null;
        data["dateAddedUtc"] = this.dateAddedUtc ? this.dateAddedUtc.toISOString() : <any>null;
        data["dateCompletedUtc"] = this.dateCompletedUtc ? this.dateCompletedUtc.toISOString() : <any>null;
        data["taskName"] = this.taskName !== undefined ? this.taskName : <any>null;
        data["taskCategory"] = this.taskCategory !== undefined ? this.taskCategory : <any>null;
        data["taskDescription"] = this.taskDescription !== undefined ? this.taskDescription : <any>null;
        return data;
    }
}

export interface IUserTaskDto {
    taskID: number;
    deleted: boolean;
    completed: boolean;
    taskPriority: number;
    dateAddedUtc: Date;
    dateCompletedUtc: Date;
    taskName: string;
    taskCategory: string;
    taskDescription: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

(<any>window).NlpBaseClient = NlpBaseClient;